import * as _crossmarkio_typings_build_src_schema_v4_apps from '@crossmarkio/typings/build/src/schema/v4/apps';
import EventEmitter from 'events';
import * as typings from '@crossmarkio/typings/sdk';
export { typings };
import * as _crossmarkio_typings_build_src_schema_v4 from '@crossmarkio/typings/build/src/schema/v4';

interface ActiveRequest {
    resolve: (value: unknown) => void;
    reject: (value: unknown) => void;
}
declare class Api extends EventEmitter {
    #private;
    sdk: Sdk;
    active: Map<string, ActiveRequest>;
    uuid: string;
    connected: boolean;
    target: string | undefined;
    timestamp: number | undefined;
    constructor(sdk: Sdk);
    awaitRequest: (request: Partial<typings.Models.Request>) => Promise<typings.Models.FullResponse>;
    request: (request: Partial<typings.Models.Request>) => string;
}

declare class Env {
    isAndroid: boolean;
    isIos: boolean;
    isOpera: boolean;
    isWindows: boolean;
    isSSR: boolean;
    isXApp: boolean;
    isMobile: boolean;
    isDesktop: boolean;
    constructor();
}

declare interface CustomEmitter {
    on(event: typeof typings.EVENTS.PING, listener: () => void): this;
    on(event: typeof typings.EVENTS.CLOSE, listener: () => void): this;
    on(event: typeof typings.EVENTS.OPEN, listener: () => void): this;
    on(event: typeof typings.EVENTS.SIGNOUT, listener: () => void): this;
    on(event: typeof typings.EVENTS.USER_CHANGE, listener: (user: typeof typings.BasicUser) => void): this;
    on(event: typeof typings.EVENTS.NETWORK_CHANGE, listener: (network: typeof typings.BasicNetwork) => void): this;
    on(event: typeof typings.EVENTS.RESPONSE, listener: (resp: typings.Models.Response) => void): this;
    on(event: typeof typings.EVENTS.ALL, listener: (all: typeof typings.CatchAllEvent) => void): this;
    on(event: string, listener: Function): this;
}
declare class CustomEmitter extends EventEmitter {
}

declare interface Mount {
    on(event: 'detected', listener: () => void): this;
    on(event: string, listener: Function): this;
}
declare class Mount extends EventEmitter {
    isDetected?: boolean;
    sdk: Sdk;
    constructor(sdk: Sdk);
    loop: (timeout?: number) => Promise<boolean>;
}

declare const enum State {
    active = "active",
    unactive = "unactive",
    error = "error"
}
declare class Session {
    sdk: Sdk;
    user?: typeof typings.BasicUser;
    network?: typeof typings.BasicNetwork;
    address?: string;
    isOpen: boolean;
    lastPing?: number;
    state: State;
    responses: Map<string, typings.Models.FullResponse>;
    constructor(sdk: Sdk);
    handleDetect: () => Promise<void>;
    handlePing: () => number;
    handleClose: () => boolean;
    handleOpen: () => boolean;
    handleSignOut: () => void;
    handleNetworkChange: (network: {
        network: typeof typings.BasicNetwork;
    }) => void;
    handleUserChange: (user: {
        user: typeof typings.BasicUser;
    }) => void;
    handleResponse: (resp: typings.Models.FullResponse) => void;
}

declare class Async {
    sdk: Sdk;
    api: Api;
    session: Session;
    mount: Mount;
    constructor(sdk: Sdk);
    signInAndWait: (hex?: string) => Promise<typeof typings.Models.SignInFullResponse>;
    signAndWait: (tx: typeof typings.Models.AllTransactionRequest, opts?: typeof typings.Models.ExtendedSignOpts) => Promise<typeof typings.Models.SignFullResponse>;
    submitAndWait: (address: string, txblob: string, opts?: typeof typings.Models.ExtendedSignOpts) => Promise<typeof typings.Models.SubmitFullResponse>;
    signAndSubmitAndWait: (tx: typeof typings.Models.AllTransactionRequest, opts?: typeof typings.Models.ExtendedSignOpts) => Promise<typeof typings.Models.SignAndSubmitFullResponse>;
    bulkSignAndWait: (txns: (typeof typings.Models.IndexedTransactionRequest)[], opts?: typeof typings.Models.ExtendedSignOpts) => Promise<typeof typings.Models.BulkSignFullResponse>;
    bulkSubmitAndWait: (address: string, txblobs: string[], opts?: typeof typings.Models.ExtendedSignOpts) => Promise<typeof typings.Models.BulkSubmitFullResponse>;
    bulkSignAndSubmitAndWait: (txns: (typeof typings.Models.IndexedTransactionRequest)[], opts?: typeof typings.Models.ExtendedSignOpts) => Promise<typeof typings.Models.BulkSignAndSubmitFullResponse>;
    encryptAndWait: {
        aes: (address: string, data: string, opts?: typeof typings.Models.CryptOpts) => Promise<typeof typings.Models.EncryptFullResponse>;
    };
    decryptAndAwait: {
        aes: (address: string, hex: string, opts?: typeof typings.Models.CryptOpts) => Promise<typeof typings.Models.DecryptFullResponse>;
    };
    isLockedAndWait: () => Promise<typeof typings.Models.IsLockedFullResponse>;
    versionAndWait: () => Promise<typeof typings.Models.VersionFullResponse>;
    verifyAndWait: (hex: string) => Promise<typeof typings.Models.VerifyFullResponse>;
    connect: (timeout?: number) => Promise<boolean>;
    detect: (timeout?: number) => Promise<boolean>;
}

declare class Sync {
    sdk: Sdk;
    api: Api;
    session: Session;
    mount: Mount;
    constructor(sdk: Sdk);
    signIn: (hex?: string) => string;
    sign: (tx: typeof typings.Models.AllTransactionRequest, opts?: typeof typings.Models.ExtendedSignOpts) => string;
    submit: (address: string, txblob: string, opts?: typeof typings.Models.ExtendedSignOpts) => string;
    signAndSubmit: (tx: typeof typings.Models.AllTransactionRequest, opts?: typeof typings.Models.ExtendedSignOpts) => string;
    bulkSign: (txns: (typeof typings.Models.IndexedTransactionRequest)[], opts?: typeof typings.Models.ExtendedSignOpts) => string;
    bulkSubmit: (address: string, txblobs: string[], opts?: typeof typings.Models.ExtendedSignOpts) => string;
    encrypt: {
        aes: (address: string, data: string, opts?: typeof typings.Models.CryptOpts) => string;
    };
    decrypt: {
        aes: (address: string, hex: string, opts?: typeof typings.Models.CryptOpts) => string;
    };
    bulkSignAndSubmit: (txns: (typeof typings.Models.IndexedTransactionRequest)[], opts?: typeof typings.Models.ExtendedSignOpts) => string;
    getResponse: (id: string) => typings.Models.FullResponse | undefined;
    isConnected: () => boolean | undefined;
    isInstalled: () => boolean | undefined;
    isLocked: () => string;
    isOpen: () => boolean;
    version: () => string;
    verify: (hex: string) => string;
    getAddress: () => string | undefined;
    getNetwork: () => _crossmarkio_typings_build_src_schema_v4.Types.BasicNetwork | undefined;
    getUser: () => _crossmarkio_typings_build_src_schema_v4.Types.BasicUser | undefined;
}

interface Opts {
    project: typeof typings.Config.config.title;
}
declare class Sdk extends CustomEmitter {
    mount: Mount;
    api: Api;
    session: Session;
    env: Env;
    async: Async;
    sync: Sync;
    methods: Async & Sync;
    app: _crossmarkio_typings_build_src_schema_v4_apps.Apps.titles;
    constructor(opts?: Opts);
}

declare const _default$2: Sdk;

declare const _default$1: Sdk;

declare namespace index_d {
  export { _default$1 as embark, _default$2 as xmark };
}

declare const _default: Sdk;

export { _default as default, index_d as modules, Sdk as vanilla };
